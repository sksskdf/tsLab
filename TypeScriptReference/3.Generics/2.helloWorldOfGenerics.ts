/*
제네릭의 Hello World (Hello World of Generics)

먼저 제네릭의 “hello world”인 identity 함수를 해봅시다. identity 함수는 인수로 무엇이 오던 그대로 반환하는 함수입니다. echo 명령과 비슷하게 생각할 수 있습니다.
제네릭이 없다면, identity 함수에 특정 타입을 주어야 합니다:
*/

function identity(arg: number): number {
  return arg;
}

//또는 any 타입을 사용하여 identity 함수를 기술할 수 있습니다:

function identity2(arg: any): any {
  return arg;
}

/*
any를 쓰는 것은 함수의 arg가 어떤 타입이든 받을 수 있다는 점에서 제네릭이지만, 실제로 함수가 반환할 때 어떤 타입인지에 대한 정보는 잃게 됩니다. 
만약 number 타입을 넘긴다고 해도 any 타입이 반환된다는 정보만 얻을 뿐입니다.
대신에 우리는 무엇이 반환되는지 표시하기 위해 인수의 타입을 캡처할 방법이 필요합니다. 여기서는 값이 아닌 타입에 적용되는 타입 변수 를 사용할 것입니다.
*/

function identity3<Type>(arg: Type): Type {
  return arg;
}

/*
identity 함수에 Type라는 타입 변수를 추가했습니다. Type는 유저가 준 인수의 타입을 캡처하고 (예 - number), 이 정보를 나중에 사용할 수 있게 합니다. 
여기에서는 Type를 반환 타입으로 다시 사용합니다. 인수와 반환 타입이 같은 타입을 사용하고 있는 것을 확인할 수 있습니다. 
이를 통해 타입 정보를 함수의 한쪽에서 다른 한쪽으로 운반할 수 있게끔 합니다.

이 버전의 identity 함수는 타입을 불문하고 동작하므로 제네릭이라 할 수 있습니다. 
any를 쓰는 것과는 다르게 인수와 반환 타입에 number를 사용한 첫 번째 identity 함수만큼 정확합니다. (즉, 어떤 정보도 잃지 않습니다)

일단 제네릭 identity 함수를 작성하고 나면, 두 가지 방법 중 하나로 호출할 수 있습니다. 
첫 번째 방법은 함수에 타입 인수를 포함한 모든 인수를 전달하는 방법입니다.
*/

let output = identity3<string>("myString"); // 출력 타입은 'string'입니다.

/*
여기서 우리는 함수를 호출할 때의 인수 중 하나로써 Type를 string으로 명시해 주고 인수 주변에 () 대신 <>로 감싸주었습니다.

두 번째 방법은 아마 가장 일반적인 방법입니다. 여기서는 타입 인수 추론 을 사용합니다 — 즉, 우리가 전달하는 인수에 따라서 컴파일러가 Type의 값을 자동으로 정하게 하는 것입니다:
*/

let output2 = identity3("myString"); // 출력 타입은 'string'입니다.

/*
타입 인수를 꺾쇠괄호(<>)에 담아 명시적으로 전달해 주지 않은 것을 주목하세요. 
컴파일러는 값인 "myString"를 보고 그것의 타입으로 Type를 정합니다. 
인수 추론은 코드를 간결하고 가독성 있게 하는 데 있어 유용하지만 더 복잡한 예제에서 컴파일러가 타입을 유추할 수 없는 경우엔 명시적인 타입 인수 전달이 필요할 수도 있습니다.
*/